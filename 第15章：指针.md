## 指针类型和值
    在Go中，一个无名指针类型的字面形式为*T，其中T为一个任意类型。类型T称为
指针类型*T的基类型（base type）。 如果一个指针类型的基类型为T，则我们可
以称此指针类型为一个T指针类型
    如果一个指针类型的底层类型（第14章）是*T，则它的基类型为T。
    如果两个无名指针类型的基类型为同一类型，则这两个无名指针类型亦为同一类
型。

## 如何获取一个指针值？

1. 我们可以用内置函数new来为任何类型的值开辟一块内存并将此内存块的起始
地址做为此值的地址返回。 假设T是任一类型，则函数调用new(T)返回一个
类型为*T的指针值。 存储在返回指针值所表示的地址处的值（可被看作是一
个匿名变量）为T的零值。
2. 我们也可以使用前置取地址操作符&来获取一个可寻址的值的地址。 对于一
个类型为T的可寻址的值t，我们可以用&t来取得它的地址。&t的类型为
*T。

目前，我们只需知道所有变量都是可以寻址的；但是所有常量、函数返回值和强制转换结果都是不可寻址的。 

## 指针（地址）解引用

    解引用一个nil指针将产生一个恐慌（第13章）。

## Go指针的一些限制

- Go指针不支持算术运算

    运算p++和p-2都是非法的。
    *p++将被编译器认为是合法的并且等价于(*p)++。

- 一个指针类型的值不能被随意转换为另一个指针类型

    在Go中，只有如下某个条件被满足的情况下，一个类型为T1的指针值才能被显式转换为另一个指针类型T2：
    1. 类型T1和T2的底层类型必须一致（忽略结构体字段的标签）。 特别地，如果类型T1和T2中只要有一个是无名类型（第14章）并且它们的底层类型一致（考虑结构体字段的标签），则此转换可以是隐式的。
    2. 类型T1和T2都为无名类型并且它们的基类型的底层类型一致（忽略结构体字段的标签）。
    `
        type MyInt int64
        type Ta *int64
        type Tb *MyInt
    `

    1. 类型*int64的值可以被隐式转换到类型Ta，反之亦然（因为它们的底层类型均为*int64）。
    2. 类型 *MyInt的值可以被隐式转换到类型Tb，反之亦然（因为它们的底层类型均为*MyInt）。
    3. 类型*MyInt的值可以被显式转换为类型*int64，反之亦然（因为它们都是无名的并且它们的基类型的底层类型均为int64）。
    4. 类型Ta的值不能直接被转换为类型Tb，即使是显式转换也是不行的。 但是，通过上述三条事实，通过三层显式转换Tb((*MyInt)((*int64)(ta)))，一个类型为Ta的值ta可以被间接地转换为类型Tb。

    这些指针类型的任何值都无法被转换到类型*uint64。

- 一个指针值不能和其它任一指针类型的值进行比较

    Go指针值是支持（使用比较运算符==和!=）比较的。 但是，两个指针只有在下列任一条件被满足的时候才可以比较：
    1. 这两个指针的类型相同。
    2. 其中一个指针可以被隐式转换为另一个指针的类型。换句话说，这两个指针的类型的底层类型必须一致并且至少其中一个指针类型为无名的（考虑结构体字段的标签）。
    3. 其中一个并且只有一个指针用类型不确定的nil标识符表示。

- 一个指针值不能被赋值给其它任意类型的指针值

    一个指针值可以被赋值给另一个指针值的条件和这两个指针值可以比较的条件是一致的。
